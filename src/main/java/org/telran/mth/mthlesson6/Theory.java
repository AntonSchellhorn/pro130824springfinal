package org.telran.mth.mthlesson6;

public class Theory {

    public static void main(String[] args) {
        // 1 - sum (100-150 second) -> sum_storage (sync)
        // 2 - run ->  sum_storage -> (sync) ---> Thread.sleep
        //Object  -> wait, wait(long), wait(long, ong) , notify, notifyAll

        //Thread.sleep - усыпляет текущий поток, в котором он вызван
        // при этом, если этот поток заблокировал мьютекс объекта
        // то он будет заблокирован до тех пор , пока этот поток не
        // проснется и не отпустит мьютекс объекта
        // Вызать Thread.sleep в потоке, когда он захватил объект
        // очень и очень плохая идея, так все другие потоки тоже
        // будут вынуждены встать в блокировку если они обратились
        // к этому объекту

        //Wait
        //Wait(long mills)
        //Wait(long mills,long nanos)

        //Метод wait можно вызвать только из синхронизированного блока
        //Когда потока захватывает мьютекс объекта и понимает, что в
        //данный момент времени он не может работать с этим объектом,
        //например чего не хватает, то мы можем перевести этот поток
        //в состояние ожидания на ЭТОМ объекте!!! Но самое главное то,
        //что поток, который уйдет в состояние ожидания на этом объекте,
        //ОТПУСТИТ мьютекс этого объекта, давая возможность другим потокам
        //работать с этим объектом

        //Потоки, которые находятся в состоянии ожидания на каком-то объекте
        //можно пробудить , вызвав метод notify() или notifyAll() - на тот случай
        //если на этом объекте находится в состоянии ожидания много потоков

        // Вызван wait() на каком -то объекте, но никто не вызвал notify() ((
        // тогда поток уснет навечно
        // wait(timeout) - если никто за это время не разбудит поток, то он
        // проснется сам
    }
}
